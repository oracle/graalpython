diff --git a/numpy/core/src/_simd/_simd_convert.inc b/numpy/core/src/_simd/_simd_convert.inc
index 46e0444..261cf5b 100644
--- a/numpy/core/src/_simd/_simd_convert.inc
+++ b/numpy/core/src/_simd/_simd_convert.inc
@@ -101,9 +101,8 @@ simd_sequence_from_iterable(PyObject *obj, simd_data_type dtype, Py_ssize_t min_
     if (dst == NULL) {
         return NULL;
     }
-    PyObject **seq_items = PySequence_Fast_ITEMS(seq_obj);
     for (Py_ssize_t i = 0; i < seq_size; ++i) {
-        simd_data data = simd_scalar_from_number(seq_items[i], info->to_scalar);
+        simd_data data = simd_scalar_from_number(PySequence_Fast_GET_ITEM(seq_obj, i), info->to_scalar);
         npyv_lanetype_u8 *sdst = dst + i * info->lane_size;
         memcpy(sdst, &data.u64, info->lane_size);
     }
diff --git a/numpy/core/src/common/ufunc_override.c b/numpy/core/src/common/ufunc_override.c
index 4fb4d4b..06552f0 100644
--- a/numpy/core/src/common/ufunc_override.c
+++ b/numpy/core/src/common/ufunc_override.c
@@ -79,13 +79,12 @@ PyUFunc_HasOverride(PyObject * obj)
 /*
  * Get possible out argument from kwds, and returns the number of outputs
  * contained within it: if a tuple, the number of elements in it, 1 otherwise.
- * The out argument itself is returned in out_kwd_obj, and the outputs
- * in the out_obj array (as borrowed references).
+ * The out argument itself is returned in out_kwd_obj.
  *
  * Returns 0 if no outputs found, -1 if kwds is not a dict (with an error set).
  */
 NPY_NO_EXPORT int
-PyUFuncOverride_GetOutObjects(PyObject *kwds, PyObject **out_kwd_obj, PyObject ***out_objs)
+PyUFuncOverride_GetOutObjects(PyObject *kwds, PyObject **out_kwd_obj)
 {
     if (kwds == NULL) {
         Py_INCREF(Py_None);
@@ -121,13 +120,11 @@ PyUFuncOverride_GetOutObjects(PyObject *kwds, PyObject **out_kwd_obj, PyObject *
             *out_kwd_obj = NULL;
             return -1;
         }
-        *out_objs = PySequence_Fast_ITEMS(seq);
         *out_kwd_obj = seq;
         return PySequence_Fast_GET_SIZE(seq);
     }
     else {
-        Py_INCREF(*out_kwd_obj);
-        *out_objs = out_kwd_obj;
+    	*out_kwd_obj = PyTuple_Pack(1, *out_kwd_obj);
         return 1;
     }
 }
diff --git a/numpy/core/src/common/ufunc_override.h b/numpy/core/src/common/ufunc_override.h
index 5da95fb..3879016 100644
--- a/numpy/core/src/common/ufunc_override.h
+++ b/numpy/core/src/common/ufunc_override.h
@@ -27,12 +27,11 @@ PyUFunc_HasOverride(PyObject *obj);
 /*
  * Get possible out argument from kwds, and returns the number of outputs
  * contained within it: if a tuple, the number of elements in it, 1 otherwise.
- * The out argument itself is returned in out_kwd_obj, and the outputs
- * in the out_obj array (as borrowed references).
+ * The out argument itself is returned in out_kwd_obj.
  *
  * Returns 0 if no outputs found, -1 if kwds is not a dict (with an error set).
  */
 NPY_NO_EXPORT int
-PyUFuncOverride_GetOutObjects(PyObject *kwds, PyObject **out_kwd_obj, PyObject ***out_objs);
+PyUFuncOverride_GetOutObjects(PyObject *kwds, PyObject **out_kwd_obj);
 
 #endif  /* NUMPY_CORE_SRC_COMMON_UFUNC_OVERRIDE_H_ */
diff --git a/numpy/core/src/multiarray/array_coercion.c b/numpy/core/src/multiarray/array_coercion.c
index 562e4f0..1ed009b 100644
--- a/numpy/core/src/multiarray/array_coercion.c
+++ b/numpy/core/src/multiarray/array_coercion.c
@@ -1106,7 +1106,6 @@ PyArray_DiscoverDTypeAndShape_Recursive(
     }
 
     npy_intp size = PySequence_Fast_GET_SIZE(seq);
-    PyObject **objects = PySequence_Fast_ITEMS(seq);
 
     if (update_shape(curr_dims, &max_dims,
                      out_shape, 1, &size, NPY_TRUE, flags) < 0) {
@@ -1128,7 +1127,7 @@ PyArray_DiscoverDTypeAndShape_Recursive(
     /* Recursive call for each sequence item */
     for (Py_ssize_t i = 0; i < size; i++) {
         max_dims = PyArray_DiscoverDTypeAndShape_Recursive(
-                objects[i], curr_dims + 1, max_dims,
+        		PySequence_Fast_GET_ITEM(seq, i), curr_dims + 1, max_dims,
                 out_descr, out_shape, coercion_cache_tail_ptr, fixed_DType,
                 flags, never_copy);
 
diff --git a/numpy/core/src/multiarray/arrayfunction_override.c b/numpy/core/src/multiarray/arrayfunction_override.c
index af53d78..1fcd6d3 100644
--- a/numpy/core/src/multiarray/arrayfunction_override.c
+++ b/numpy/core/src/multiarray/arrayfunction_override.c
@@ -72,12 +72,11 @@ get_implementing_args_and_methods(PyObject *relevant_args,
 {
     int num_implementing_args = 0;
 
-    PyObject **items = PySequence_Fast_ITEMS(relevant_args);
     Py_ssize_t length = PySequence_Fast_GET_SIZE(relevant_args);
 
     for (Py_ssize_t i = 0; i < length; i++) {
         int new_class = 1;
-        PyObject *argument = items[i];
+        PyObject *argument = PySequence_Fast_GET_ITEM(relevant_args, i);
 
         /* Have we seen this type before? */
         for (int j = 0; j < num_implementing_args; j++) {
@@ -156,12 +155,11 @@ NPY_NO_EXPORT PyObject *
 array_function_method_impl(PyObject *func, PyObject *types, PyObject *args,
                            PyObject *kwargs)
 {
-    PyObject **items = PySequence_Fast_ITEMS(types);
     Py_ssize_t length = PySequence_Fast_GET_SIZE(types);
 
     for (Py_ssize_t j = 0; j < length; j++) {
         int is_subclass = PyObject_IsSubclass(
-            items[j], (PyObject *)&PyArray_Type);
+        		PySequence_Fast_GET_ITEM(types, j), (PyObject *)&PyArray_Type);
         if (is_subclass == -1) {
             return NULL;
         }
diff --git a/numpy/core/src/multiarray/compiled_base.c b/numpy/core/src/multiarray/compiled_base.c
index 66e79b0..771ce75 100644
--- a/numpy/core/src/multiarray/compiled_base.c
+++ b/numpy/core/src/multiarray/compiled_base.c
@@ -1414,6 +1414,7 @@ arr_add_docstring(PyObject *NPY_UNUSED(dummy), PyObject *args)
         return NULL;
     }
 
+#if 0 // GraalPy change
 #define _ADDDOC(doc, name)                                              \
         if (!(doc)) {                                                   \
             doc = docstr;                                               \
@@ -1486,6 +1487,7 @@ arr_add_docstring(PyObject *NPY_UNUSED(dummy), PyObject *args)
     }
 
 #undef _ADDDOC
+#endif // GraalPy change
 
     Py_RETURN_NONE;
 }
diff --git a/numpy/core/src/multiarray/iterators.c b/numpy/core/src/multiarray/iterators.c
index f959162..2ef579b 100644
--- a/numpy/core/src/multiarray/iterators.c
+++ b/numpy/core/src/multiarray/iterators.c
@@ -1400,7 +1400,11 @@ arraymultiter_new(PyTypeObject *NPY_UNUSED(subtype), PyObject *args,
         Py_DECREF(fast_seq);
         return multiiter_wrong_number_of_args();
     }
-    ret = multiiter_new_impl(n, PySequence_Fast_ITEMS(fast_seq));
+    PyObject* seq[n];
+    for (int i = 0; i < n; i++) {
+    	seq[i] = PySequence_Fast_GET_ITEM(fast_seq, i);
+    }
+    ret = multiiter_new_impl(n, seq);
     Py_DECREF(fast_seq);
     return ret;
 }
diff --git a/numpy/core/src/multiarray/methods.c b/numpy/core/src/multiarray/methods.c
index c68a0a2..a833c4f 100644
--- a/numpy/core/src/multiarray/methods.c
+++ b/numpy/core/src/multiarray/methods.c
@@ -1095,7 +1095,6 @@ any_array_ufunc_overrides(PyObject *args, PyObject *kwds)
     int nin, nout;
     PyObject *out_kwd_obj;
     PyObject *fast;
-    PyObject **in_objs, **out_objs;
 
     /* check inputs */
     nin = PyTuple_Size(args);
@@ -1106,21 +1105,20 @@ any_array_ufunc_overrides(PyObject *args, PyObject *kwds)
     if (fast == NULL) {
         return -1;
     }
-    in_objs = PySequence_Fast_ITEMS(fast);
     for (i = 0; i < nin; ++i) {
-        if (PyUFunc_HasOverride(in_objs[i])) {
+        if (PyUFunc_HasOverride(PySequence_Fast_GET_ITEM(fast, i))) {
             Py_DECREF(fast);
             return 1;
         }
     }
     Py_DECREF(fast);
     /* check outputs, if any */
-    nout = PyUFuncOverride_GetOutObjects(kwds, &out_kwd_obj, &out_objs);
+    nout = PyUFuncOverride_GetOutObjects(kwds, &out_kwd_obj);
     if (nout < 0) {
         return -1;
     }
     for (i = 0; i < nout; i++) {
-        if (PyUFunc_HasOverride(out_objs[i])) {
+        if (PyUFunc_HasOverride(PySequence_Fast_GET_ITEM(out_kwd_obj, i))) {
             Py_DECREF(out_kwd_obj);
             return 1;
         }
diff --git a/numpy/core/src/umath/extobj.c b/numpy/core/src/umath/extobj.c
index 6b9a27e..8de94fb 100644
--- a/numpy/core/src/umath/extobj.c
+++ b/numpy/core/src/umath/extobj.c
@@ -283,7 +283,7 @@ _check_ufunc_fperr(int errmask, PyObject *extobj, const char *ufunc_name) {
     if (!errmask) {
         return 0;
     }
-    fperr = npy_get_floatstatus_barrier((char*)extobj);
+    fperr = npy_get_floatstatus_barrier((char*)ufunc_name);
     if (!fperr) {
         return 0;
     }
diff --git a/tools/cythonize.py b/tools/cythonize.py
index 002b2fa..fd05e01 100755
--- a/tools/cythonize.py
+++ b/tools/cythonize.py
@@ -48,9 +48,14 @@ def process_pyx(fromfile, tofile):
     if tofile.endswith('.cxx'):
         flags.append('--cplus')
 
-    subprocess.check_call(
-        [sys.executable, '-m', 'cython'] + flags + ["-o", tofile, fromfile])
+    print("processing: " + (" ".join(flags + ["-o", tofile, fromfile])))
+    from Cython.Compiler.CmdLine import parse_command_line
+    from Cython.Compiler.Main import compile
 
+    options, sources = parse_command_line(flags + ["-o", tofile, fromfile])
+    result = compile(sources, options)
+    if result.num_errors > 0:
+        raise Exception("Cython either isn't installed or it failed.") from e
 
 def process_tempita_pyx(fromfile, tofile):
     import npy_tempita as tempita
