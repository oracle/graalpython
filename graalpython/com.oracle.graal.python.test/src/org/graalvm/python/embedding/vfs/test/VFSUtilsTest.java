/*
 * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.graalvm.python.embedding.vfs.test;

import org.graalvm.python.embedding.test.EmbeddingTestUtils;
import org.graalvm.python.embedding.tools.exec.BuildToolLog;
import org.graalvm.python.embedding.tools.vfs.VFSUtils;
import org.junit.Test;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.graalvm.python.embedding.test.EmbeddingTestUtils.createLauncher;
import static org.graalvm.python.embedding.test.EmbeddingTestUtils.delete;
import static org.graalvm.python.embedding.test.EmbeddingTestUtils.deleteDirOnShutdown;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class VFSUtilsTest {

    private static final String GRAALPY_VERSION_PREFIX;
    private static final String INPUT_PACKAGES_PREFIX;

    static {
        try {
            Field f = VFSUtils.class.getDeclaredField("GRAALPY_VERSION_PREFIX");
            f.setAccessible(true);
            GRAALPY_VERSION_PREFIX = (String) f.get(VFSUtils.class);
            f = VFSUtils.class.getDeclaredField("INPUT_PACKAGES_PREFIX");
            f.setAccessible(true);
            INPUT_PACKAGES_PREFIX = (String) f.get(VFSUtils.class);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    private static final String PACKAGE_WAS_REMOVED = "A package with transitive dependencies was removed since last install, setting up a clean venv";
    private static final String LOCK_FILE_HEADER = "generated by graalpy tests\nwith a two line header";
    private static final String PACKAGES_CHANGED_ERROR = "packages changed in lock file %s, current packages %s, previous packages %s";
    private static final String MISSING_LOCK_FILE_WARNING = "missing lock file";
    private static final CharSequence STALE_VENV = "Stale GraalPy virtual environment, updating to";

    private static final class TestLog implements BuildToolLog {
        private final StringBuilder output = new StringBuilder();

        private void addLine(String s) {
            this.output.append('\n').append(s);
        }

        private void clearOutput() {
            output.delete(0, output.length());
        }

        public void subProcessOut(String s) {
            println("[subout] ", s);
            addLine(s.toString());
        }

        public void subProcessErr(String s) {
            println("[suberr] ", s);
            addLine(s.toString());
        }

        public void info(String s) {
            println("[info] ", s);
            addLine(s);
        }

        public void warning(String s) {
            println("[warn] ", s);
            addLine(s);
        }

        public void warning(String s, Throwable t) {
            println("[warn] ", s);
            t.printStackTrace();
            addLine(s);
        }

        public void error(String s) {
            println("[err] ", s);
            addLine(s);
        }

        @Override
        public void debug(String s) {
            println("[debug] ", s);
            addLine(s);
        }

        @Override
        public boolean isWarningEnabled() {
            return true;
        }

        @Override
        public boolean isInfoEnabled() {
            return true;
        }

        @Override
        public boolean isErrorEnabled() {
            return true;
        }

        @Override
        public boolean isSubprocessOutEnabled() {
            return true;
        }

        @Override
        public boolean isDebugEnabled() {
            return isVerbose();
        }

        public String getOutput() {
            return output.toString();
        }

        static void println(String... args) {
            if (isVerbose()) {
                System.out.println(String.join(" ", args));
            }
        }

        private static boolean isVerbose() {
            return Boolean.getBoolean("com.oracle.graal.python.test.verbose");
        }
    }

    /**
     * tests scenarios without lock file logic available, but not used
     *
     * - packages declared only in plugin config - lock file path is provided, but does not exist
     */
    @Test
    public void withPackagesOnlyFromPluginConfig() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("withPackagesOnlyFromPluginConfig");
        Path venvDir = tmpDir.resolve("venv");
        deleteDirOnShutdown(tmpDir);

        // test with a not existing lock file path
        // the maven and gradle plugins always send the default lock file path, no matter if the
        // file exists or not
        Path lockFile = tmpDir.resolve("lockFile.txt");
        Path contents = venvDir.resolve("contents");

        // no packages, lock file file does not exist - does nothing
        log.clearOutput();
        createVenv(venvDir, "0.1", log, lockFile);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));

        log.clearOutput();

        // install packages
        log.clearOutput();
        createVenv(venvDir, "0.1", log, lockFile, "hello-world", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

        // install packages again, assert that venv wasn't created again and packages weren't
        // installed
        log.clearOutput();
        createVenv(venvDir, "0.1", log, lockFile, "hello-world", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains("tiny-tiny"));
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

        // remove tiny-tiny, assert that venv was deleted and created anew as we don't know if there
        // were any transitive deps left
        log.clearOutput();
        createVenv(venvDir, "0.1", log, lockFile, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains(PACKAGE_WAS_REMOVED));
        assertTrue(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains("tiny-tiny"));
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world");

        // install only hello-world again, assert that venv wasn't created and
        // packages weren't installed
        log.clearOutput();
        createVenv(venvDir, "0.1", log, lockFile, "hello-world==0.2");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains("pip uninstall"));
        assertTrue(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.2");
    }

    /**
     * tests scenarios without lock file logic - e.g. when called from jbang
     *
     * - packages declared only in plugin config - and lock file path is not provided
     */
    @Test
    public void withoutLockFile() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("withoutLockFile");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        createVenv(venvDir, "0.1", log);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world==0.1");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world==0.1", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1", "tiny-tiny");
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world==0.1");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
        log.clearOutput();
    }

    @Test
    public void lockFile() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("emptyLockFile");
        Path venvDir = tmpDir.resolve("venv");
        deleteDirOnShutdown(tmpDir);

        Path lockFile = tmpDir.resolve("graalpy.lock");

        Files.createFile(lockFile);

        createWithLockFile(venvDir, lockFile, log);

        List<String> validLockFileHeader = createLockFileHeader("0.1");

        List<String> lockFileList;
        int headerLineCount = LOCK_FILE_HEADER.split("\n").length;
        // bogus line in header comment
        for (int i = 0; i < headerLineCount - 1; i++) {
            lockFileList = new ArrayList<>(validLockFileHeader);
            lockFileList.set(i, "test");
            createWithLockFile(venvDir, lockFile, log, lockFileList);
        }

        // bogus graalPyVersion line
        int graalpVersionLineIdx = headerLineCount;
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(graalpVersionLineIdx, "test");
        createWithLockFile(venvDir, lockFile, log, lockFileList);

        // empty graalPyVersion line
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(graalpVersionLineIdx, GRAALPY_VERSION_PREFIX);
        createWithLockFile(venvDir, lockFile, log, lockFileList);
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(graalpVersionLineIdx, GRAALPY_VERSION_PREFIX + "   ");
        createWithLockFile(venvDir, lockFile, log, lockFileList);

        // bogus input packages line
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(3, "test");
        createWithLockFile(venvDir, lockFile, log, lockFileList);

        // empty input packages line
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(3, INPUT_PACKAGES_PREFIX);
        createWithLockFile(venvDir, lockFile, log, lockFileList);
        lockFileList = new ArrayList<>(validLockFileHeader);
        lockFileList.set(3, INPUT_PACKAGES_PREFIX + "   ");
        createWithLockFile(venvDir, lockFile, log, lockFileList);
    }

    private static void createWithLockFile(Path venvDir, Path lockFile, TestLog log, List<String> lines) throws IOException {
        createWithLockFile(venvDir, lockFile, log, lines.toArray(new String[lines.size()]));
    }

    private static void createWithLockFile(Path venvDir, Path lockFile, TestLog log, String... lines) throws IOException {
        Files.write(lockFile, new ArrayList<>(Arrays.asList(lines)), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile), "invalid lock file format");
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        log.clearOutput();
    }

    private static void lock(Path venvDir, Path lockFile, TestLog log, String... packages) throws IOException {
        VFSUtils.lockPackages(venvDir, Arrays.asList(packages), lockFile, LOCK_FILE_HEADER, createLauncher(venvDir), "0.1", log);
    }

    private static List<String> createLockFileHeader(String graalPyVersion, String... packages) {
        List<String> lines = new ArrayList<>();
        for (String s : LOCK_FILE_HEADER.split("\n")) {
            lines.add("# " + s);
        }
        lines.add(GRAALPY_VERSION_PREFIX + graalPyVersion);
        lines.add(INPUT_PACKAGES_PREFIX + String.join(",", packages));
        return lines;
    }

    @Test
    public void installAndLock() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("installAndLock");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        Path lockFile = tmpDir.resolve("graalpy.lock");

        // install request from plugin config, it pulls in transitive pkgs, and
        // we get the missing lock file warning
        createVenv(venvDir, "0.1", log, lockFile, "requests");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests");
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // lock without version
        lock(venvDir, lockFile, log, "requests");
        assertTrue(Files.exists(lockFile));
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        // lock with version
        Files.delete(lockFile);
        lock(venvDir, lockFile, log, "requests==2.32.2");
        checkLockFile(lockFile, new String[]{"requests==2.32.2"}, "requests==2.32.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // reinstall without exact version declared - fails
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile, "requests"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // reinstall again - no more warning
        delete(venvDir);
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // reinstall with lower version - ok
        Files.delete(lockFile);
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1");
        // we changed version from 2.32.2 to 2.32.1, we do not know if the prev version did not
        // leave
        // any transitive deps, so the venv is deleted and created again
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.1");
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();
        // lock
        lock(venvDir, lockFile, log, "requests==2.32.1");
        checkLockFile(lockFile, new String[]{"requests==2.32.1"}, "requests==2.32.1", "charset-normalizer", "idna", "urllib3", "certifi");
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna", "urllib3", "certifi");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // add tiny-tiny - fails because inconsistent with lock file
        assert Files.exists(lockFile);
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(String.format(PACKAGES_CHANGED_ERROR, lockFile, "requests==2.32.1, tiny-tiny==0.2", "requests==2.32.1")));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.1");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // delete lock and try again tiny-tiny - now ok
        Files.delete(lockFile);
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();
        // lock
        lock(venvDir, lockFile, log, "requests==2.32.1", "tiny-tiny==0.2");
        checkLockFile(lockFile, new String[]{"requests==2.32.1", "tiny-tiny==0.2"}, "requests==2.32.1", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // install again - OK
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // update in declared packages requests version back to 2.32.2 - fails
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(String.format(PACKAGES_CHANGED_ERROR, lockFile, "requests==2.32.2, tiny-tiny==0.2", "requests==2.32.1, tiny-tiny==0.2")));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // delete lock and try again new hello-world version - now ok
        Files.delete(lockFile);
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2");
        // we changed version from 2.32.2 to 2.32.1, we do not know if the prev version did not
        // leave
        // any transitive deps, so the venv is deleted and created again
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.2", "tiny-tiny==0.2");
        assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();
        // lock with new requests version
        lock(venvDir, lockFile, log, "requests==2.32.2", "tiny-tiny==0.2");
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkLockFile(lockFile, new String[]{"requests==2.32.2", "tiny-tiny==0.2"}, "requests==2.32.2", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // install again - OK
        createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkLockFile(lockFile, new String[]{"requests==2.32.2", "tiny-tiny==0.2"}, "requests==2.32.2", "tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();

        // remove requests from packages list - fails because it is still in lock
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile, "tiny-tiny==0.2"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(String.format(PACKAGES_CHANGED_ERROR, lockFile, "tiny-tiny==0.2", "requests==2.32.2, tiny-tiny==0.2")));
        log.clearOutput();
        // lock only with tiny-tiny
        lock(venvDir, lockFile, log, "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), true);
        checkLockFile(lockFile, new String[]{"tiny-tiny==0.2"}, "tiny-tiny==0.2");
        // requests transitive deps are gone as well
        checkInstalledPackages(venvDir.resolve("installed.txt"), "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();
        // try again
        createVenv(venvDir, "0.1", log, lockFile, "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains("Virtual environment is up to date with lock file"));
        log.clearOutput();

        // reinstall with new graalpy version
        createVenv(venvDir, "0.2", log, lockFile, "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains(STALE_VENV));
        assertTrue(log.getOutput().contains("pip install -r")); // lock file is used
        checkInstalledPackages(venvDir.resolve("installed.txt"), "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
        log.clearOutput();
    }

    @Test
    public void packageRemoved() throws InvocationTargetException, NoSuchMethodException, IllegalAccessException, IOException {
        Path tmpDir = Files.createTempDirectory("packageRemoved");
        deleteDirOnShutdown(tmpDir);

        assertFalse(callPackageRemoved(Collections.emptyList(), Collections.emptyList(), Collections.emptyList()));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Collections.emptyList(), Collections.emptyList()));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1==1", "pkg2==1")));

        assertFalse(callPackageRemoved(Arrays.asList("pkg1=="), Arrays.asList("pkg1=="), Arrays.asList("pkg1==1")));
        assertFalse(callPackageRemoved(Arrays.asList("==pkg1"), Arrays.asList("==pkg1"), Arrays.asList("pkg1==1")));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1==1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
        assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));

        assertTrue(callPackageRemoved(Collections.emptyList(), Arrays.asList("pkg"), Arrays.asList("pkg==1")));
        assertTrue(callPackageRemoved(Arrays.asList("pkg2"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
        assertTrue(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1==1", "pkg2==1")));

        assertTrue(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1=="), Arrays.asList("pkg1==1")));
        assertTrue(callPackageRemoved(Arrays.asList("pkg1=="), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
        assertTrue(callPackageRemoved(Arrays.asList("==pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));

        assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1==1"), Arrays.asList("pkg1==1")));
        assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1==1", "pkg2==1"), Arrays.asList("pkg1==1", "pkg2==1")));
        assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1==1", "pkg2==1")));
    }

    private static boolean callPackageRemoved(List<String> packages, List<String> contents, List<String> installed)
                    throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Method m = VFSUtils.class.getDeclaredMethod("removedFromPluginPackages", List.class, List.class, List.class);
        m.setAccessible(true);
        return (boolean) m.invoke(VFSUtils.class, packages, contents, installed);
    }

    private interface ExceptionCall {
        void call() throws Exception;
    }

    private static void checkException(Class<?> cls, ExceptionCall c) {
        checkException(cls, c, null);
    }

    private static void checkException(Class<?> cls, ExceptionCall c, String msg) {
        try {
            c.call();
        } catch (Exception e) {
            if (e instanceof InvocationTargetException) {
                assertEquals(cls, e.getCause().getClass());
            } else {
                assertEquals(cls, e.getClass());
            }
            if (msg != null) {
                assertEquals(msg, e.getMessage());
            }
        }
    }

    private static void checkVenvCreate(String output, boolean b) {
        if (b) {
            assertTrue(output.contains("-m venv"));
            assertTrue(output.contains("-m ensurepip"));
        } else {
            assertFalse(output.contains("-m venv"));
            assertFalse(output.contains("-m ensurepip"));
        }
    }

    private static void checkInstalledPackages(Path instaledFile, String... packages) throws IOException {
        assertTrue(Files.exists(instaledFile));
        checkPackages(instaledFile, Files.readAllLines(instaledFile), packages);
    }

    private static void checkLockFile(Path lockFile, String[] inputPackages, String... installedPackages) throws IOException {
        assertTrue(Files.exists(lockFile));
        List<String> lines = Files.readAllLines(lockFile);
        List<String> header = createLockFileHeader("0.1", inputPackages);
        assertTrue(lines.size() >= header.size());
        for (int i = 0; i < header.size(); i++) {
            assertEquals(header.get(i), lines.get(i));
        }
        checkPackages(lockFile, lines, installedPackages);
    }

    private static void checkPackages(Path file, List<String> lines, String... packages) throws IOException {
        lines = lines.stream().filter(line -> !line.trim().startsWith("#") && !line.trim().isEmpty()).toList();
        assertEquals(packages.length, lines.size());
        for (String pkg : packages) {
            boolean found = false;
            String pkgDef = pkg.indexOf("==") >= 0 ? pkg : pkg + "==";
            for (String line : lines) {
                assert line.contains("==");
                if (line.startsWith(pkgDef)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                fail("file " + file + " does not contain package " + pkg);
            }
        }
    }

    private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, String... packages) throws IOException {
        EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, packages);
    }

    private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, Path lockFile, String... packages) throws IOException {
        EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, lockFile, LOCK_FILE_HEADER, MISSING_LOCK_FILE_WARNING, PACKAGES_CHANGED_ERROR,
                        packages);
    }

    private static void checkVenvContentsFile(Path contents, String graalPyVersion, String... packages) throws IOException {
        assertTrue(Files.exists(contents));
        List<String> lines = Files.readAllLines(contents);

        assertEquals(graalPyVersion, lines.get(0));
        lines.remove(0);
        assertEquals(packages.length, lines.size());
        if (!lines.containsAll(Arrays.asList(packages))) {
            fail(String.format("expected %s to contain all from %s", lines, Arrays.asList(packages)));
        }
    }
}
